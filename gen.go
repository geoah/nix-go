//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"flag"
	"io"
	"log"
	"net/http"
	"os"
	"os/exec"
	"strings"
	"sync"
	"sync/atomic"
	"text/template"
)

const baseURL = "https://go.dev/dl/"

var tmpl = template.Must(template.New("").Parse(`# Code generated by go run gen.go; DO NOT EDIT.
{
{{- range . }}
  {{ .K }} = {
  {{- with .V }}
    os = "{{ .os }}";
    arch = "{{ .arch }}";
    version = "{{ .version }}";
    url = "{{ .url }}";
    hash = "{{ .hash }}";
  {{- end }}
  };
{{- end }}
}
`))

var (
	outPath                 = "dl.nix"
	dumpPath                = ""
	includeAll              = true
	maxConcurrentPrefetches = 2
	gcPrefetched            = true
)

type Release struct {
	Version string `json:"version"`
	Stable  bool   `json:"stable"`
	Files   []File `json:"files"`
}

type File struct {
	Filename string `json:"filename"`
	OS       string `json:"os"`
	Arch     string `json:"arch"`
	Version  string `json:"version"`
	SHA256   string `json:"sha256"`
	Kind     string `json:"kind"` // "archive", "installer", "source"
}

func listReleases() ([]Release, error) {
	q := "?mode=json"
	if includeAll {
		q += "&include=all"
	}

	resp, err := http.Get(baseURL + q)
	if err != nil {
		return nil, err
	}

	body, err := io.ReadAll(resp.Body)
	_ = resp.Body.Close()
	if err != nil {
		return nil, err
	}

	var v []Release
	if err := json.Unmarshal(body, &v); err != nil {
		return nil, err
	}

	return v, nil
}

type pair struct {
	K string
	V map[string]string
}

func main() {
	flag.StringVar(&outPath, "out", outPath, "output path")
	flag.StringVar(&dumpPath, "dump", dumpPath, "dump path to use if exists instead of making network requests")
	flag.BoolVar(&includeAll, "all", includeAll, "include all Go releases")
	flag.IntVar(&maxConcurrentPrefetches, "concurrency", maxConcurrentPrefetches, "limit concurrent nix-prefetch-url invocations")
	flag.BoolVar(&gcPrefetched, "gc", gcPrefetched, "automatically delete prefetched store paths")
	flag.Parse()
	if maxConcurrentPrefetches < 1 {
		maxConcurrentPrefetches = 1
	}

	releases, err := listReleases()
	if err != nil {
		log.Fatalf("list releases: %v", err)
	}

	var out []pair

	var loaded bool
	if dumpPath != "" {
		dump, err := os.ReadFile(dumpPath)
		switch {
		case os.IsNotExist(err):
		case err != nil:
			log.Fatalf("read dump file: %v", err)
		default:
			if err := json.Unmarshal(dump, &out); err != nil {
				log.Fatalf("decode dump file: %v", err)
			}
			loaded = true
		}
	}
	if !loaded {
		var wg sync.WaitGroup
		sema := make(chan struct{}, maxConcurrentPrefetches)
		for _, r := range releases {
			version := strings.TrimPrefix(r.Version, "go")
			packageName := underscoreVersion(version, r.Stable)

			for _, f := range r.Files {
				if !isSupportedFile(f) {
					continue
				}

				system := nixSystem(f)
				if _, ok := supportedSystems[system]; !ok {
					continue
				}

				filename := f.Filename
				u := baseURL + filename

				var hash string
				if f.SHA256 != "" {
					b, err := hex.DecodeString(f.SHA256)
					if err != nil {
						log.Printf("decode SHA256 for %q (using nix-prefetch-url as a fallback): %v", filename, err)
					} else {
						hash = sriSHA256(b)
					}
				}

				attrs := map[string]string{
					"os":      f.OS,
					"arch":    f.Arch,
					"version": version,
					"url":     u,
					"hash":    hash,
				}

				out = append(out, pair{
					K: system + ".go_" + packageName,
					V: attrs,
				})

				if hash != "" {
					continue
				}
				wg.Add(1)
				sema <- struct{}{}
				go func() {
					defer wg.Done()
					defer func() { <-sema }()
					defer log.Printf("done %q", filename)

					log.Printf("processing %q", filename)
					attrs["hash"] = prefetchURL(u)
				}()
			}
		}
		wg.Wait()
	}

	if dumpPath != "" {
		dump, err := json.Marshal(out)
		if err != nil {
			log.Fatalf("encode dump file: %v", err)
		}
		if err := os.WriteFile(dumpPath, dump, 0644); err != nil {
			log.Fatalf("write dump file: %v", err)
		}
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, out); err != nil {
		log.Fatalf("execute template: %v", err)
	}

	if err := os.WriteFile(outPath, buf.Bytes(), 0644); err != nil {
		log.Fatalf("write output file: %v", err)
	}
}

func prefetchURL(u string) string {
	var stdout, stderr strings.Builder
	c := exec.Command("nix-prefetch-url", "--type", "sha256", "--print-path", u)
	c.Stdout, c.Stderr = &stdout, &stderr
	if err := c.Run(); err != nil {
		prefetchFatalf(u, err.Error(), stderr.String())
	}

	out := stdout.String()
	lines := strings.Split(strings.TrimSpace(out), "\n")
	if len(lines) != 2 {
		prefetchFatalf(u, "unexpected output format", out)
	}

	if gcPrefetched {
		storePath := lines[1]
		combined, err := exec.Command("nix-store", "--delete", "--", storePath).CombinedOutput()
		if err != nil {
			combined = bytes.ReplaceAll(bytes.TrimSpace(combined), []byte{'\n'}, []byte{'\n', '\t'})
			log.Printf("nix-store --delete %q: %v\n\t%s", storePath, err, combined)
		}
	}

	hash, ok := decodeNixBase32(lines[0])
	if !ok {
		prefetchFatalf(u, "cannot decode base32 hash (expected non-standard Nix format)", out)
	}

	return sriSHA256(hash)
}

var prefetchAlreadyFailed uint32

func prefetchFatalf(u string, msg string, out string) {
	if atomic.SwapUint32(&prefetchAlreadyFailed, 1) != 0 {
		return
	}
	log.Fatalf("nix-prefetch-url for %q: %s\n\t%s",
		u, msg,
		strings.ReplaceAll(
			strings.TrimSpace(out),
			"\n", "\n\t",
		),
	)
}

var supportedSystems = map[string]struct{}{
	"aarch64-linux":  {},
	"aarch64-darwin": {},
	"i686-linux":     {},
	"x86_64-darwin":  {},
	"x86_64-linux":   {},
}

func isSupportedFile(f File) bool {
	return f.Kind == "archive" &&
		// Skip pre-1.5 releases that shipped osx1.6 and osx1.8 variants.
		// These are very old and likely do not run anymore on any modern
		// macOS system. If there is a use case for them, its probably so
		// niche that it is not worth supporting here.
		!strings.Contains(f.Filename, "-osx")
}

func nixSystem(f File) string {
	arch := f.Arch
	switch arch {
	case "amd64":
		arch = "x86_64"
	case "arm64":
		arch = "aarch64"
	case "386":
		arch = "i686"
	}
	return arch + "-" + f.OS
}

func underscoreVersion(s string, stable bool) string {
	var b strings.Builder

	n := len(s)
	if !stable {
		n += 1
	}
	b.Grow(n)

	var sep bool
	for i := 0; i < len(s); i++ {
		c := s[i]
		switch {
		case c == '.':
			c = '_'

		// For unstable versions, insert an underscore on the first
		// non-digit character (i.e. so 1.19beta1 becomes 1_19_beta1).
		case ('0' > c || '9' < c) && !sep && !stable:
			sep = true
			_ = b.WriteByte('_')
		}

		_ = b.WriteByte(c)
	}

	return b.String()
}

func decodeNixBase32(s string) ([]byte, bool) {
	const chars = "0123456789abcdfghijklmnpqrsvwxyz"
	dst := make([]byte, len(s)*5/8)
	for n := 0; n < len(s); n++ {
		c := s[len(s)-n-1]
		digit := strings.IndexByte(chars, c)
		if digit == -1 {
			return nil, false
		}
		b := uint(n * 5)
		i := b / 8
		j := b % 8
		dst[i] |= byte(digit) << j
		carry := byte(digit) >> (8 - j)
		if i == uint(len(dst)-1) {
			if carry != 0 {
				return nil, false
			}
		} else {
			dst[i+1] |= carry
		}
	}
	return dst, true
}

func sriSHA256(src []byte) string {
	return "sha256-" + base64.StdEncoding.EncodeToString(src)
}
